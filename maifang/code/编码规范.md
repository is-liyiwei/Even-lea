##### vant 用的是 <font size="3" color="#f00">v2.10.x</font>

https://youzan.github.io/vant

<font face="黑体" size="3" color="#f00">创建文件命令 npm run newPage</font>
<font face="黑体" size="3" color="#f00">更新接口命令 npm run createApi</font>

<font face="黑体" size="6" color="#f00">文件名字</font>
1、页面文件命名用最基本的驼峰命名法即可，组件文件名字首字母必须为 <font size="3" color="#f00">Yhcxxxxxx</font>
2、每个.vue 文件都必须有 <font size="3" color="#f00">identifierName</font> 字段，这个使用 npm run newPage 创建的文件都会自动生成

<font face="黑体" size="6" color="#f00">代码规范</font>

1、全局 数据的 Key，必须用 <font size="3" color="#f00">app</font> 作为前缀，参考 pluginCommon.js
2、所有的组件，过滤器，等一些 vue 的方法，只在全局注册，不能在局部注册，比如说在一个文件看到一个方法或者变量，命名是 <font size="3" color="#f00">appxxxxxxx</font> 这样的，那么第一反应就要在 <font size="3" color="#f00">pluginCommon.js</font> 字段 查找，<font size="3" color="#f00">且必须能找到</font>
3、样式文件优先使用 scss/app 目录下面预定义的 class，这个不强制要求，尽量优先用
4、<font size="3" color="#f00">块级元素只能用 div，行内元素只能用 span</font>，其他的例如 h1,h2,p,header 等等都禁止使用，小程序只能用 view 和 text 标签，即 div = view / span = text
5、每个文件的数据最好都用一个 pageModel，一个 queryModel，一个 pagePagination，一个 pageList 来存储数据，其他的可以自定义
6、对于业务数据，暂时不需要考虑数据的验证，例如必须为整数，不能为空等等，优先考虑功能的实现，有些比较重要的数据则需要严格处理下，例如用户余额，这个就需要判断是否是数字，是否会精度丢失问题
7、页面路由跳转不能用 router-link，必须用 js 代码控制

<font face="黑体" size="6" color="#f00">http 接口请求代码规范，这个用 npm run createApi 生成即可，一般不用手动操作</font>

```
例如后端有一个这样的接口

POST /api/v1/accounts/login 用户登录

那么这个方法的命名就是mothod + url 驼峰命名法
即post + accounts + login

// 用户登录
export function postAccountsLogin(body = {}, query = {}) {
  return http({
    url: 'accounts/login',
    method: 'post',
    data: body,
    query: query
  });
}

```

<font face="黑体" size="6" color="#f00">调用代码示例</font>

```
let query = {}
let body = {}

<!-- vue -->
this.YhcAjax.postAccountsLogin(body, query).then(res => {
  console.log(res)
})

<!-- 小程序 -->
global.YhcAjax.postAccountsLogin(body, query).then(res => {
  console.log(res)
})

vue和小程序两者区别就是一个是this，一个是global

若没有body需要传值，而有query，那么第一个参数写{}

this.YhcAjax.postAccountsLogin({}, query).then(res => {
  console.log(res)
})

```

<font face="黑体" size="6" color="#f00">常用组件和方法，这些在全局封装好了</font>

> Loading

```
this.appShowLoading()
this.appHideLoading()

window.appShowLoading()
window.appHideLoading()
```

> Toast

```
this.appShowToast({
  message: '文字信息提示'
})

window.appShowToast({
  message: '文字信息提示'
})
```

> 输入框通用的赋值绑定方法

```
mockDetail.vue有demo
包括如何把input输入组件变成picker使用的形式
这里主要是from表单的内容

```

> Picker

```
methodsHandle() {
  this.$once('pickerSelectItem', jsonRes => {
    // 这里写业务代码
    // console.log(JSON.parse(jsonRes))
  })
  // picker组件的数据，values数量代表列数量，默认数据不联动
  const dataList = [
    {
      values: ['1', '2', '3']
    },
    {
      values: ['4', '5', '6']
    }
  ]
  this.appPickerSelectOpen(
    identifierName,
    'pickerSelectItem',
    dataList
  )
}
```

> TimePicker

```
mockDetail.vue
dateTimeHandle方法，与picker方法类似
```

> Area(城市选择)

```
methodsHandle() {
  this.$once('pickerAreaSelect', jsonRes => {
    // 这里写业务代码
    // console.log(JSON.parse(jsonRes))
  })
  this.appPickerAreaSelectOpen(identifierName, 'pickerAreaSelect')
}
```

> ActionSheet(选择器)

```
methodsHandle() {
  this.$once('actionSheetKey', async item => {
    console.log(JSON.parse(item))
  })
  this.appActionSheetOpen(identifierName, 'actionSheetKey', [
    { name: '选项一' },
    { name: '选项二' },
    { name: '选项三' }
  ])
}

额外方法

<!-- 设置取消文案，默认值是: '取消' -->
this.appActionSheetSetCancelText(str)
<!-- 设置描述文案，默认值是: '' -->
this.appActionSheetSetDescription(str)
```

> 常用路由跳转

```
mockList.vue有demo，里面有用到这两个方法
this.appBackPage
this.appToPage - 有三个公共参数(pageName, id, type)

其他的特殊参数路由跳转需要页面自定义
<!-- 如果参数有些敏感数据则需要加密传输 -->

this.$router.push({
  name: 'xxxxx',
  query: {
    key1: '',
    key2: '',
    <!-- json形式的参数要先stringify -->
    jsonKey: JSON.stringify(json)
  }
})

敏感数据需要加密处理
window.appEncrypt(id)

然后页面上通过appDecrypt方法解密
this.itemId = window.appDecrypt(this.$route.query.id)

```

<font face="黑体" size="4" color="#08c518">路由返回带参数-实验性功能</font>

```
有这样一个场景
A -> B -> C -> B -> A(这个时候A带着B和C页面设置好的参数)

B页面调用方法
this.appPageBackSetParams('B', 'B的参数')
C页面调用方法
this.appPageBackSetParams('C', 'C的参数')

这里会有两次进入B页面，但是这个方法是不受这些限制，只需要在用到的那次使用
本质上是全局缓存一个值

A页面需要做的判断

<!-- 获取 -->
let BBBBB = this.appPageBackGetParams('B')
let CCCCC = this.appPageBackGetParams('C')
<!-- 删除 -->
<!-- 一般来说获取了就要删除，除非还要在其他页面使用，但是这个极端的情况基本不会有 -->
this.appPageBackDeleteParams('B')
this.appPageBackDeleteParams('C')
if (BBBBB) {
  // 你的操作
}
if (CCCCC) {
  // 你的操作
}

```

> 金额格式化，金额都是以分为单位

```
方法路径，里面有说明，更多用法查看文件
src\utils\fixMoney.js

mockDetail.vue目录下面有demo，里面有用到这两个方法
this.appFixMoney(moneyModel, fixArray, 'yuan2fen')
this.appFixMoney(moneyModel, fixArray, 'fen2yuan')

window.appFixMoney(moneyModel, fixArray, 'yuan2fen')
window.appFixMoney(moneyModel, fixArray, 'fen2yuan')
```

> 时间格式化

```

<!-- 修复时间 -->
this.appFixDateBoundary(时间戳, 'start')
this.appFixDateBoundary(时间戳, 'end')
window.appFixDateBoundary(时间戳, 'start')
window.appFixDateBoundary(时间戳, 'end')

start -> 1583078400000 -> (2020-03-02 00:00:00)
end -> 1583164799000 -> (2020-03-02 23:59:59)

<!-- 格式时间 -->
src\utils\parseTime.js，更多用法查看文件
时间 -> 字符串
该方法可以绑定vue的全局过滤器上面，参考mockList.vue

也绑定在window上面
window.appParseTime(时间戳, '{y}-{m}-{d} {h}:{i}:{s}')
-> yyyy-mm-dd hh:mm:ss

<!-- 根据时间戳返回年月日时分秒 -->
let { year, month, day, hour, minute, second } = this.appGetDateYMDHMS(时间戳')
let { year, month, day, hour, minute, second } = window.appGetDateYMDHMS(时间戳')

```

> 分页请求处理(滚动加载)

```
这个直接用v-appReachBottom指令
请求参数参考pagePagination值
mockList.vue有demo，里面有用到
```

> 文件上传

```

async methodsHandle() {
  this.$once('uploadHandle', async fileList => {
    // for (let index = 0; index < fileList.length; index++) {
    //   const file = fileList[index]
    //   await this.appUploadManagerSend(file).then(res => {
    //     console.log(res)
    //   })
    // }
  })
  this.appUploadManagerSetMultiple(true)
  this.appUploadManagerHandle(identifierName, 'uploadHandle')
  let fileInfo = this.appUploadManagerGetFileInfo()
  console.log(fileInfo)
}

// 公共方法

this.appUploadManagerSetMultiple(true)
this.appUploadManagerSetAccept('audio/*,video/*,image/*')
let fileInfo = this.appUploadManagerGetFileInfo()

```

> navbar - 顶部导航栏

```

初始化
this.appNavBarInit()

设置文字，标题，左边箭头旁的标题，右边标题
this.appNavBarSetTitle(str)
this.appNavBarSetLeftText(str)
this.appNavBarSetRightText(str)

显示/隐藏，左边箭头
this.appNavBarSetLeftArrowShow()
this.appNavBarSetLeftArrowHide()

绑定事件，需要在用到的页面.vue文件里面的methods定义方法，没有事件处理则不需要定义
appNavBarRightClick
appNavBarLeftClick

其中appNavBarLeftClick方法不定义，则返回上一页，即点击返回箭头，默认执行this.appBackPage()方法


```

> tabbar - 底部导航栏

```

// 默认样式
其中icon是vant内置的
this.appTabBarInit([
  {
    icon: 'home-o',
    name: 'index',
    pageName: 'index'
  },
  {
    icon: 'search',
    name: 'mockList',
    pageName: 'mockList'
  },
  {
    icon: 'friends-o',
    name: '标签3',
    pageName: ''
  },
  {
    icon: 'setting-o',
    name: '标签4',
    pageName: ''
  }
])

// 自定义样式

// 需要调用这个方法
this.appTabBarSetType('custom')
this.appTabBarInit([
  {
    normal: require('./assets/app/1.png'),
    active: require('./assets/app/2.png'),
    name: '支付',
    pageName: 'pay'
  },
  {
    normal: require('./assets/app/3.png'),
    active: require('./assets/app/4.png'),
    name: '个人中心',
    pageName: 'memberCenter'
  }
])

// 公共方法

// 设置选中的文字颜色
this.appTabBarSetActiveColor('#D92F38')

<!-- 上面的方法一般在App.vue文件使用，下面的方法在普通页面使用 -->
<!-- 注意：appTabBarInit方法默认会执行一次this.appTabBarShow() -->

// 设置选中第几项
this.appTabBarSetActiveIndex(1)

// 设置显示
this.appTabBarShow()

// 设置隐藏
this.appTabBarHide()
```

> 本地缓存

```

storages 目录下面有公共方法，例如常用的一个功能，本地缓存用户 id

例如 xTkoen 这个 key
import xToken from "@/storages/xToken";
存：xToken.set(id)
取：xToken.get()
删：xToken.remove()

其他新增则以此类推，参考 storages/xToken 这个文件写法和命名即可

import key from "@/storages/key";
存：key.set(data)
取：key.get()
删：key.remove()

```

> 数据验证，这个用的不多

```

src\utils\validationData.js
this.appValidationData
window.appValidationData
用到时候再说明

```

> 图片裁剪功能

```
<!-- html部分 -->
<input
  type="file"
  name="image"
  accept="image/*"
  @change="methodsHandle"
/>

<!-- js方法 -->
methodsHandle(e) {
  this.$once('avatarEdit', base64Data => {
    // 这里写业务代码
    // console.log(JSON.parse(base64Data))
  })
  this.appImageFileToBase64(e.target.files[0]).then(res => {
    // 支持三种尺寸，横屏 / 竖屏 / 方形
    const imgSize = 'landscape'
    // const imgSize = 'vertical'
    // const imgSize = 'square'
    this.appAvatarDialogOpen(
      identifierName,
      'avatarEdit',
      res,
      imgSize
    )
  })
}
```

> 多语言

```

页面使用
{{ this.$root.appLang['1'] }}

切换方法
// type:string = zh / en / jap
this.$root.appSetLang(type)

```

> 腾讯地图选择地址

```
methodsHandle() {
  const QQ_MAP_SDK_KEY = 'EBFBZ-VSC3Q-2G756-GIGOA-WASXO-YRBD4'
  this.$once('qqMapSelect', jsonRes => {
    // 这里写业务代码
    // console.log(JSON.parse(jsonRes))
  })
  this.appQqMapOpen(identifierName, 'qqMapSelect', QQ_MAP_SDK_KEY)
}
```

<font face="黑体" size="6" color="#f00">暂时不用下面组件</font>

Lazyload - 图片懒加载
List - 上拉加载，这个用我们自己的自定义指令就好，mockList.vue 有 demo

<font face="黑体" size="6" color="#f00">数据注意的地方</font>

涉及到金额的数据，都用分作为单位
涉及到时间都用毫秒，也就是 js 的时间戳

项目页面不需要 100%完全还原 UI 图，相差个几 px 都没关系，但是要一眼看上去相差不大就好，主要是项目功能要 100%实现

<font face="黑体" size="6" color="#f00">编码遵守的规范</font>

必须用 flex 布局，其他的 float 不能用

定位也不能乱用，flex 可以弄的尽量用

组件只负责接受数据，展示数据，反馈指令，其他的功能都由页面实现

没啥了，开始写 bug 吧

<font face="黑体" size="6" color="#f00">其他</font>

```

keep-alive 组件，暂定，用到再说明
preload.vue 页面一般不用，和 app 做混合开发时候再用
vuex 一般来说不需要用到，用到再说明，vuex里面的identifierName格式为路径
例如const identifierName = `src/store/modules/user.js`
每个新的 store 文件都必须强制使用namespace: true

暂时不使用 vuex 的辅助函数，例如
mapGetter，mapState等等
获取可以使用最原始的代码，例如获取store/modiles/index.js的state的值

computed: {
  userInfo() {
    return this.$store.state.index.userInfo;
  }
}

```
